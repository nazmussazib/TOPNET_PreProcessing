

#include <mpi.h>
#include <math.h>
#include <queue>
#include "commonLib.h"
#include "linearpart.h"
#include "createpart.h"
#include "tiffIO.h"
#include "shape/shapefile.h"

//  Defines needed for triangle
#define REAL double
#define ANSI_DECLARATORS
#include "triangle.h"
using namespace std;

//
//  Function to compute weights associated with Delauney triangle raingauges.
//

float ratio(tdpartition *annraingrid,int iag,int jag,int ig,int jg)
{

	//	if((iag .lt. 1) .or. (iag .gt. agny) 
	//     1   .or. (jag .lt. 1) .or. (jag .gt. agnx))then
	//c	    write(6,*)"Basin grid outside annual grid array"
	//c	    write(6,*)"Weight will not be scaled by annrain grid"
	//		ratio = 1.
	//	    return
	//	endif
	//      if((ig .lt. 1) .or. (ig .gt. agny) 
	//     1  .or. (jg .lt. 1) .or. (jg .gt. agnx))then
	//c	    write(6,*)"Raingauge outside annual grid array"
	//c	    write(6,*)"Weight will not be scaled by annrain grid"
	//	    ratio = 1.
	//	    return
	//	endif
	//	if(annraingrid(ig,jg) .le. 0. .or. 
	//     +   annraingrid(iag,jag) .le. 0.)then
	//c	    write(6,*)"Annual rainfall grid is zero at a gauge "
	//c	  	write(6,*)"Weight will not be scaled by annrain grid"
	//		ratio = 1.
	//		return
	//	endif 
	float rat=1.;
	float denom;
	float tempFloat;
	if(annraingrid->isInPartition(jag,iag) 
		&& annraingrid->isInPartition(jg,ig)
		&& (!annraingrid->isNodata(jag,iag))
		&& (!annraingrid->isNodata(jg,ig))
		&& (annraingrid->getData(jg,ig,denom) > 0.))
		rat = annraingrid->getData(jag,iag,tempFloat)/denom;
	return(rat);
}

//c   function to return nearest guage to location xi, yi	     
int nrest(double xi,double yi,double *x,double *y,int ngauge)
{
	double dist,distn;
	distn = sqrt((xi-x[0])*(xi-x[0]) + (yi - y[0])*(yi - y[0]));
	int nn = 0;
	for(int j=1; j<ngauge; j++) //do 2 j = 2,ngauge
	{
		dist = sqrt((xi-x[j])*(xi-x[j]) + (yi - y[j])*(yi - y[j]));
		if(dist < distn)
		{
			distn = dist;
			nn = j;
		}
	}
	return(nn);
}


//
int rainweighteval(int nb, tdpartition *basingrid, int *narr, float **warr,int ngmax, int ntmax, int nrows, int ncols,tdpartition *trindexgrid,
				   tdpartition *annraingrid, int *sites,double *x,double *y,int (*trilist)[3], tiffIO *wgrid, tiffIO *arIO, long gmin)
{

	// arguments
	//		c inputs
	//c		nb				= number of basins
	//c		basingrid(i,j)	= sub-basin number at cell i,j
	//c		ngmax			= maximum possible number of raingauges
	//c		igy,igx			= maximum no of rows and columns in a grid
	//c		nrows, ncols	= actual number of rows and columns in this grid
	//c		bndbox(1:4)		= xmin,ymin,xmax,ymax 
	//c		cellsize		= width of a cell (in metres)
	//c		annraingrid(i,j) = mean annual rain at cell i,j
	//c					(data generated by Matlab m-file annraingrid.m)
	//c		trifilename = name of file containing info about triangles
	//c					(data generated by Matlab m-file trindex.m)
	//c outputs
	//c		narr(1:nb)		= number of cells in basin isub
	//c		warr(1:nb,1:ngmax)	= weight to apply for gauge ig in basin isub
	//c		trindexgrid		= index of triangle to use at cell i,j
	//c		sites(1:ngmax) = site numbers of the raingauges
	//c locals
	double w[3],del,x1,x2,x3,y1,y2,y3,xi,yi;
	int i,j,ig,jg,lun,ind,isub,k,ngauge,ntri;
	int kg[3];

	bool found;
	ngauge=ngmax;
	ntri=ntmax;

	// we must set warr and narr to 0 before we start
	for(isub=0; isub<nb; isub++)
	{
		narr[isub]=0;
		for(ig=0; ig<ngauge; ig++)
		{
			warr[isub][ig]=0.;
		}
	}
	//do 5 isub=1,nb				       ! nb is number of sub-basins
	//  narr(isub) = 0				   ! narr is number of cells in sub-basin 
	//  do 5 ig=1,ngauge				   ! warr is weight for ig'th gauge
	//   5	    warr(isub,ig) = 0.			   ! to get rain in basin isub

	//c now loop over all grid cells collecting weight information

	int notfound = 0;   //!  Count how many cells do not fall within triangles
	double ytopedge=wgrid->getYTopEdge();
	double xleftedge=wgrid->getXLeftEdge();
	double arytopedge=arIO->getYTopEdge();
	double arxleftedge=arIO->getXLeftEdge();
	double dx=wgrid->getdxA();
	double dy=wgrid->getdyA();
	double ardx=arIO->getdxA();
	double ardy=arIO->getdyA();
	int32_t tempLong;
	int lastind;
	for(i=0; i<nrows; i++)
	{
		//do 30 i = 1, nrows
		yi=ytopedge  -(i+.5)*dy;  //   ! y co-ord of cell center
		// yi=bndbox(4)-(i-1+.5)*cellsize   ! y co-ord of cell center
		for(j=0; j<ncols; j++)
		{
			//	  do 20 j = 1, ncols
			//if(dotg .eq. 1)trindexgrid(i,j) = -9999  ! initialize triangle grid
			//isub = basingrid->getData(j,i,tempLong);		 //  ! which basin is this cell in
			if ( !basingrid->isNodata(j,i))
			{
				isub=basingrid->getData(j,i,tempLong)-gmin;  // adressing is grid value - gmin
				narr[isub]=narr[isub]+1;
				xi=xleftedge+(j+.5)*dx;
				//xi=bndbox(1)+(j-1+.5)*cellsize ! x co-ord of cell center
				found = false; 
				lastind=-1;
				for(ind=0; ind<ntri; ind++)  	//do 25 ind = 1,ntri   ! search through triangles for one that has all weights positive
				{
					for(k=0; k<3; k++) //do 10 k = 1, 3			   ! kg has indices of the 3 gauges to use for this cell
					{
						kg[k]=trilist[ind][k]; 	  
					}

					x1=x[kg[0]-1]	;//			   ! x1,y1,x2,y2,x3,y3 are
					y1=y[kg[0]-1]; //				   ! co-ords of the 3 gauges
					x2=x[kg[1]-1];	//			   ! which influence this cell
					y2=y[kg[1]-1];
					x3=x[kg[2]-1];//				   ! w1,w2,w3 are weights for
					y3=y[kg[2]-1]; //				   ! those gauges
					//c these formulae adapted from the 'linear' subfunction in matlab 5.1's
					//c griddata.m function.  w(1,2,3) are weights for gauges 1,2,3
					del  =  (x2-x1) * (y3-y1) - (x3-x1) * (y2-y1);
					w[2] = ((x1-xi) * (y2-yi) - (x2-xi) * (y1-yi)) / del;
					w[1] = ((x3-xi) * (y1-yi) - (x1-xi) * (y3-yi)) / del;
					w[0] = ((x2-xi) * (y3-yi) - (x3-xi) * (y2-yi)) / del;
					if(w[0] >= 0. && w[1] >= 0. && w[2] >= 0.)
					{
						//! found triangle
						//c we expect to find each pixel in exactly one triangle
						//c if a pixel is right on a vertex or right on a line, it will seem to belong to several triangles
						//c that is ok, and we'll just use the first triangle we find
						//c when this happens we get one or two of the w's=0
						if(found) { 
							//c don't want to do any work if we find a second triangle
							//c however we get upset if we find two triangles, and are not at a vertex or on a line
							if (w[0]*w[1]*w[2]>0.) 
								printf("Error in triangle coords, Multiple triangles\n");
							//     1				  write(6,*)"Error in triangle coords",
							//     2										" - Multiple triangles"
						}else
						{
							found = true;
							lastind=ind;
							trindexgrid->setData(j,i,(int32_t) (ind+1) );// ! record which triangle the cell is in
							int iag = int( (arytopedge-yi) / ardy ); //! row/col in annual grid
							int jag = int( (xi-arxleftedge) / ardx );
							for(k=0; k<3; k++) //					do 15 k = 1, 3
							{
								//	  ig = 1 + int( (agbndbox(4)-y(kg(k))) / agcsize ) !row/col of gauge 
								//	  jg = 1 + int( (x(kg(k))-agbndbox(1)) / agcsize )
								ig = int( (arytopedge-y[kg[k]-1] )/ ardy ); //!row/col of gauge 
								jg = int( (x[kg[k]-1]-arxleftedge )/ ardx );
								//  1/4/12.  DGT corrected line below to have -1 in the second warr subscript because points in trilist count from 1 to ngauge-1
								//  while warr subscripts from 0 to ngauge-1
								warr[isub][kg[k]-1] = warr[isub][kg[k]-1] +  w[k]*ratio(annraingrid,iag,jag,ig,jg);
							}
						}
					}
				}  //   25       continue
				if(!found)
				{
					//c   Use the nearest gauge with weight 1
					int iag=int(arytopedge-yi)/ardy; //	          iag = 1 + int( (agbndbox(4)-yi) / agcsize ) ! row/col in annual grid
					int jag=int(xi-arxleftedge)/ardx; //		      jag = 1 + int( (xi-agbndbox(1)) / agcsize )
					int nn=nrest(xi,yi,x,y,ngauge); //	          nn=nrest(xi,yi,x,y,ngauge)
					ig=int(arytopedge-y[nn])/ardy; //	          ig = 1 + int( (agbndbox(4)-y(nn)) / agcsize ) !row/col of gauge 
					jg=int(x[nn]-arxleftedge)/ardx; //	          jg = 1 + int( (x(nn)-agbndbox(1)) / agcsize )
					warr[isub][nn] = warr[isub][nn] + ratio(annraingrid,iag,jag,ig,jg);
					//	          warr(isub,nn)=warr(isub,nn)
					//     1            +ratio(annraingrid,iag,jag,ig,jg,agny,agnx)
					notfound = notfound+1;
					trindexgrid->setData(j,i,(int32_t) (-nn-1) );//                if(dotg .eq. 1)trindexgrid(i,j) = -nn  ! use - gauge number
				}//c                     to record this in triangle grid
				//	      endif
				//		  narr(isub) = narr(isub) + 1  ! total up the # of cells
				//	    endif

			}
		}
	}
	for(isub=0; isub<nb; isub++)  //	do 50 isub=1,nb
	{
		for(ig=0; ig<ngauge; ig++) //	  do 50 ig=1,ngauge
		{
			if(narr[isub]>0)  //	    if ( narr(isub) .gt. 0 ) then
			{
				warr[isub][ig] = warr[isub][ig]/(float)narr[isub]; //		  warr(isub,ig) = warr(isub,ig)/narr(isub)
			}
		}
	}

				//					do 15 k = 1, 3
//					   ig = 1 + int( (agbndbox(4)-y(kg(k))) / agcsize ) !row/col of gauge 
//					   jg = 1 + int( (x(kg(k))-agbndbox(1)) / agcsize )
//c each weight depends on the proximity of gauges (the w weights)
//c and the ratio of the cell mean annual rain to raingauge mean annual rain
//c	              warr(isub,kg(k)) = warr(isub,kg(k)) +
//c     1	          w(k)*annraingrid(iag,jag)/annraingrid(ig,jg)
//					   warr(isub,kg(k)) = warr(isub,kg(k)) +
//     1				   w(k)*ratio(annraingrid,iag,jag,ig,jg,agny,agnx)
//c   Use ratio function to implement the above with error checking
//   15					continue					   ! in this basin
//				endif
//              endif
//   25       continue

//            if(.not. found)then
//c   Use the nearest gauge with weight 1
//	          iag = 1 + int( (agbndbox(4)-yi) / agcsize ) ! row/col in annual grid
//		      jag = 1 + int( (xi-agbndbox(1)) / agcsize )
//	          nn=nrest(xi,yi,x,y,ngauge)
//	          ig = 1 + int( (agbndbox(4)-y(nn)) / agcsize ) !row/col of gauge 
//	          jg = 1 + int( (x(nn)-agbndbox(1)) / agcsize )
//	          warr(isub,nn)=warr(isub,nn)
//     1            +ratio(annraingrid,iag,jag,ig,jg,agny,agnx)
//c RAW found that last two arguments were in the wrong order, and fixed it 11/10/99
//c     1            +ratio(annraingrid,iag,jag,ig,jg,agnx,agny)
//		      notfound = notfound+1
//                if(dotg .eq. 1)trindexgrid(i,j) = -nn  ! use - gauge number
//c                     to record this in triangle grid
//	      endif
//		  narr(isub) = narr(isub) + 1  ! total up the # of cells
//	    endif
//   20	  continue
//   30	continue
//c      if(notfound .gt. 0)write(6,100)Notfound
//c  100       format(1x,'Warning:',i8,
//c     1        ' grid cells not within specfied triangles')
//c all data collection is done: now we normalise by sub-basin area
//	do 50 isub=1,nb
//	  do 50 ig=1,ngauge
//	    if ( narr(isub) .gt. 0 ) then
//		  warr(isub,ig) = warr(isub,ig)/narr(isub)
//          else
//c	      write(*,*)'rainweight error: No cells for sub-basin ',isub
//	    endif
//   50	continue
//	return
//


	return(0);
}




//Calling function
int rainweight(char *wfile, char *rgfile, char *arfile, char *trifile, char *wtfile, int format)
{
	MPI_Init(NULL,NULL);{

	//Only used for timing
	int rank,size;
	MPI_Comm_rank(MCW,&rank);
	MPI_Comm_size(MCW,&size);
	if(rank==0)printf("rainweight -h version %s\n",TDVERSION);

	float wt=1.0,angle,sump,distr,dtss;
	double p;

	//  Keep track of time
	double begint = MPI_Wtime();

	//Create tiff object, read and store header info
	tiffIO wgrid(wfile, LONG_TYPE);
	long totalX = wgrid.getTotalX();
	long totalY = wgrid.getTotalY();
	double dx = wgrid.getdxA();
	double dy = wgrid.getdyA();

	//Create partition and read data
	tdpartition *wData;
	wData = CreateNewPartition(wgrid.getDatatype(), totalX, totalY, dx, dy, wgrid.getNodata());
	int nx = wData->getnx();
	int ny = wData->getny();
	int xstart, ystart;
	wData->localToGlobal(0, 0, xstart, ystart);
	wgrid.read(xstart, ystart, ny, nx, wData->getGridPointer());

	int numrgs;
	double *x, *y;
	int *ids;
	int i,j;

	//  Read rain gauge shapefile
	if(rank==0){
		if(readoutlets(rgfile, &numrgs, x, y,ids) !=0){
			printf("Exiting \n");
			MPI_Abort(MCW,5);
		}else {
			MPI_Bcast(&numrgs, 1, MPI_INT, 0, MCW);
			MPI_Bcast(x, numrgs, MPI_DOUBLE, 0, MCW);
			MPI_Bcast(y, numrgs, MPI_DOUBLE, 0, MCW);
			MPI_Bcast(ids, numrgs, MPI_INT, 0, MCW);
		}
	}
	else {
		MPI_Bcast(&numrgs, 1, MPI_INT, 0, MCW);

		//x = (double*) malloc( sizeof( double ) * numOutlets );
		//y = (double*) malloc( sizeof( double ) * numOutlets );
		x = new double[numrgs];
		y = new double[numrgs];
		ids = new int[numrgs];

		MPI_Bcast(x, numrgs, MPI_DOUBLE, 0, MCW);
		MPI_Bcast(y, numrgs, MPI_DOUBLE, 0, MCW);
		MPI_Bcast(ids, numrgs, MPI_INT, 0, MCW);
	}
//  Print to check
	for(i=0; i<numrgs; i++)
	{
		printf("x: %lf, y: %lf, Id: %d\n",x[i],y[i],ids[i]);
	}

	/*   Stuff for triangle   */
  struct triangulateio in, mid, vorout;


  /* Make necessary initializations so that Triangle can return a */
  /*   triangulation in `mid'   */
	in.numberofpoints = numrgs;
  in.numberofpointattributes = 0;
  in.pointlist = (double *) malloc(in.numberofpoints * 2 * sizeof(double));
  in.pointmarkerlist = (int *) malloc(in.numberofpoints * sizeof(int));
  
  for(i=0; i<numrgs; i++)
  {
      in.pointlist[i*2] = x[i];
	  in.pointlist[i*2+1] = y[i];
	  in.pointmarkerlist[i] = ids[i];
  }
  in.numberofsegments = 0;
  in.numberofholes = 0;


  mid.pointlist = (double *) NULL;            /* Not needed if -N switch used. */
  /* Not needed if -N switch used or number of point attributes is zero: */
  mid.pointattributelist = (double *) NULL;
  mid.pointmarkerlist = (int *) NULL; /* Not needed if -N or -B switch used. */
  mid.trianglelist = (int *) NULL;          /* Not needed if -E switch used. */
  /* Not needed if -E switch used or number of triangle attributes is zero: */
  mid.triangleattributelist = (double *) NULL;
  mid.neighborlist = (int *) NULL;         /* Needed only if -n switch used. */
  /* Needed only if segments are output (-p or -c) and -P not used: */
  mid.segmentlist = (int *) NULL;
  /* Needed only if segments are output (-p or -c) and -P and -B not used: */
  mid.segmentmarkerlist = (int *) NULL;
  mid.edgelist = (int *) NULL;             /* Needed only if -e switch used. */
  mid.edgemarkerlist = (int *) NULL;   /* Needed if -e used and -B not used. */

  /* Triangulate the points.  Switches are chosen to read and write a  */
  /*   PSLG (p), preserve the convex hull (c), number everything from  */
  /*   zero (z), assign a regional attribute to each element (A), and  */
  /*   produce an edge list (e), a Voronoi diagram (v), and a triangle */
  /*   neighbor list (n).                                              */
	
  triangulate("pczenQ", &in, &mid, &vorout);
  
  /* Free all allocated arrays, including those allocated by Triangle. */
  int ntri=mid.numberoftriangles;
  //trilist = (int **)matalloc(3,ntri,RPINTDTYPE);
  int (*trilist)[3] = new int[ntri][3];

  for(i=0; i < ntri; i++)
  {
	  for(j=0; j<3; j++)
		  trilist[i][j]=mid.trianglelist[i * 3 + j]+1;
	  printf("Triangle: %d comprises internal points %d %d %d\n",i,trilist[i][0],trilist[i][1],trilist[i][2]);
	  printf("Triangle: %d comprises id points %d %d %d\n",i,ids[trilist[i][0]-1],ids[trilist[i][1]-1],ids[trilist[i][2]-1]);
  }
	
  free(in.pointlist);
  free(in.pointmarkerlist);

  	// Find gridmin and gridmax so as to know size of array's required for indexing out of grid

	int count=0;
	int32_t tempLong;
	int32_t gmin, gmax;
    for(i=0; i<nx; i++)
	{
		for(j=0; j<ny; j++)
		{
			if(!wData->isNodata(i,j))
			{
				if(count == 0){
					gmin=wData->getData(i,j,tempLong);
					gmax=gmin;
					count=count+1;
				}
				else
				{
					wData->getData(i,j,tempLong);
					if(gmin > tempLong)gmin=tempLong;
					if(gmax < tempLong)gmax=tempLong;
				}
			}
		}
	}
	printf("gmin: %d, gmax: %d\n",gmin,gmax);
	int nd=gmax-gmin+1;

	// Read annual rainfall grid

	//  Since we are admitting annual rainfall grid not aligned with watershed grid we are limited to a single processor

	//Create tiff object, read and store header info
	tiffIO arIO(arfile, FLOAT_TYPE);
	long totalXar = arIO.getTotalX();
	long totalYar = arIO.getTotalY();
	double dxar = arIO.getdxA();
	double dyar = arIO.getdyA();

	//Create partition and read data
	tdpartition *arData;
	arData = CreateNewPartition(arIO.getDatatype(), totalXar, totalYar, dxar, dyar, arIO.getNodata());
	int nxar = arData->getnx();
	int nyar = arData->getny();
	arData->localToGlobal(0, 0, xstart, ystart);
	arIO.read(xstart, ystart, nyar, nxar, arData->getGridPointer());


  printf("Starting rainweight ...\n");

  /*  allocate memory needed  */
	int *narr = new int[nd];

	float **warr = new float*[nd];
	for (int i = 0; i < nd; ++i)
	{
		warr[i]=new float[numrgs];
		narr[i]=0;  // Count of grid values
	}

	tdpartition *trigrid;
	int32_t trinodata=MISSINGLONG;
	trigrid = CreateNewPartition(LONG_TYPE, totalX, totalY, dx, dy, trinodata);

 	rainweighteval(nd, wData, narr, warr,numrgs, ntri, ny, nx,trigrid,
		arData,ids,x,y,trilist,&wgrid,&arIO, gmin);
	for(i=0; i<nd; i++)
	{
		if(narr[i]>0)
		{
		printf("Basin: %d\n",i+gmin);
		for(j=0; j<numrgs; j++)
			printf(" %f",warr[i][j]);
		printf("\n");
		}
	}
	tiffIO triIO(trifile, LONG_TYPE, &trinodata, wgrid);
	triIO.write(xstart, ystart, ny, nx, trigrid->getGridPointer());
	if(rank==0){//open output  file
		FILE *wt;
		wt = fopen(wtfile,"w");
		if(format != 1){
			fprintf(wt,"Basin, Gauge, Weight\n");
			for(i=0; i<nd; i++)
			{
				if(narr[i]>0)
				{
					for(j=0; j<numrgs; j++)
					{
						if(warr[i][j]>0.)
							fprintf(wt,"%d, %d, %f\n",i+gmin,ids[j],warr[i][j]);
					}
				}
			}
		}
		else
		{
			fprintf(wt,"Subcatchment weights sub id, -# of gauges, gage id, weights \n");
			for(i=0; i<nd; i++)
			{
				if(narr[i]>0)
				{
					int count = 0;  // First pass to count gages
					for(j=0; j<numrgs; j++)
					{
						if(warr[i][j]>0.)
							count=count+1;
					}
					fprintf(wt,"%d %d",i+gmin,-count);
					for(j=0; j<numrgs; j++)
					{
						if(warr[i][j]>0.)
							fprintf(wt," %d %f",ids[j],warr[i][j]);
					}
					fprintf(wt, "\n");  // End line
				}
			}
		}
		fclose(wt);
	}
	//Brackets force MPI-dependent objects to go out of scope before Finalize is called
	}MPI_Finalize();

	return 0;
}


